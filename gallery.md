# Example's Gallery #

In this page we show some examples of programs, and the results that out range analysis produces for them. We use the following keys in the table:

  * **C-Src**: the C program that we have analyzed. This is an actual program, i.e., the very input to our analyzer. The comments in the program explain why this test is relevant.
  * **CFG-O**: the Control Flow Graph (CFG) of the program, as Originally produced by LLVM without any preprocessing other than the conversion to SSA-form.
  * **CFG-E**: the Control Flow Graph of the program, this time converted to the _Extended_ Static Single Assignment (E-SSA) form. This intermediate representation increases the precision of our analysis.
  * **CG-ItP**: the Contraint Graph (CG) produced during the inter-procedural range analysis. Notice that this analysis is not context-sensitive.
  * **CG-Inl**: the Contraint Graph produced after we perform function inlining. LLVM is able to inline every non-recursive call in the program, so this gives us some sort of context-sensitiveness.

| **C-Src** | **CFG-O** | **CFG-E** | **CG-ItP** | **CG-Inl** | **Comments** |
|:----------|:----------|:----------|:-----------|:-----------|:-------------|
| [![](http://homepages.dcc.ufmg.br/~fernando/images/c.jpg)](http://code.google.com/p/range-analysis/source/browse/trunk/doc/gallery/srcs/t1.c) | [![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cfgs/t1.main.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cfgs/t1.essa.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/cg.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cgs/t1.inter.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/cg.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cgs/t1.inline.pdf) | **t1.c**: an example where the inter and intra-procedural analyses should return the same results. Our analysis needs some constants in the program code to narrow the intervals bound to each variable. If we do not have these constants, then there is not much that we can do. |
| [![](http://homepages.dcc.ufmg.br/~fernando/images/c.jpg)](http://code.google.com/p/range-analysis/source/browse/trunk/doc/gallery/srcs/t2.c) | [![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cfgs/t2.main.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cfgs/t2.essa.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/cg.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cgs/t2.inter.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/cg.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cgs/t2.inline.pdf) | **t2.c**: in this example the interprocedural analysis returns better results than the intra-procedural analysis. The interprocedural version can see that the function receives a constant as a parameter, and then it uses this information to find better intervals to the variables inside function foo. |
| [![](http://homepages.dcc.ufmg.br/~fernando/images/c.jpg)](http://code.google.com/p/range-analysis/source/browse/trunk/doc/gallery/srcs/t3.c) | [![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cfgs/t3.main.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cfgs/t3.essa.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/cg.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cgs/t3.inter.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/cg.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cgs/t3.inline.pdf) | **t3.c**: in this case, like in the first example, the intra and inter-procedural analyses return the same results. The input argc comes from outside the program, we we must assume that its interval is [-inf, +inf]. |
| [![](http://homepages.dcc.ufmg.br/~fernando/images/c.jpg)](http://code.google.com/p/range-analysis/source/browse/trunk/doc/gallery/srcs/t4.c) | [![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cfgs/t4.main.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cfgs/t4.essa.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/cg.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cgs/t4.inter.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/cg.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cgs/t4.inline.pdf) | **t4.c**: this test shows how we handle comparisons between different types. These comparisons are implemented via truncation by the compiler. We can use the results of the truncate instruction to improve the bounds of some variables. For instance, if we cast a char into an integer, then we know that the resulting integer is inside [-128, +127]. |
| [![](http://homepages.dcc.ufmg.br/~fernando/images/c.jpg)](http://code.google.com/p/range-analysis/source/browse/trunk/doc/gallery/srcs/t5.c) | [![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cfgs/t5.main.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cfgs/t5.essa.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/cg.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cgs/t5.inter.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/cg.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cgs/t5.inline.pdf) | **t5.c**: a second case where the inter-procedural analysis should do better than the intra-procedural one. In this case, we have two constant arguments that the inter-procedural implementation can propagate to the body of function foo. |
| [![](http://homepages.dcc.ufmg.br/~fernando/images/c.jpg)](http://code.google.com/p/range-analysis/source/browse/trunk/doc/gallery/srcs/t6.c) | [![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cfgs/t6.main.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cfgs/t6.essa.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/cg.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cgs/t6.inter.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/cg.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cgs/t6.inline.pdf) | **t6.c**: This program shows that a context-insensitive analysis loses precision. We get some sort of context-sensitivenss through function inlining. In the non-context-sensitive approach, we end up copying both parameters, 10 and 100 to the same variable N inside the function. The same happens with the parameters 0 and 30. In the context sensitive case, we have two N's, one for each call of the function. |
| [![](http://homepages.dcc.ufmg.br/~fernando/images/c.jpg)](http://code.google.com/p/range-analysis/source/browse/trunk/doc/gallery/srcs/t7.c) | [![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cfgs/t7.main.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cfgs/t7.essa.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/cg.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cgs/t7.inter.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/cg.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cgs/t7.inline.pdf) | **t7.c**: a test case that shows how we handle a two-deep nested call. Again, the intra-procedural analysis is quite imprecise in this example. However, the inter-procedural implementation is able to propagate the known constant arguments inside the function bodies, even through multi-level function calls. |
| [![](http://homepages.dcc.ufmg.br/~fernando/images/c.jpg)](http://code.google.com/p/range-analysis/source/browse/trunk/doc/gallery/srcs/t8.c) | [![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cfgs/t8.main.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cfgs/t8.essa.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/cg.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cgs/t8.inter.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/cg.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cgs/t8.inline.pdf) | **t8.c**: this file illustrates the fact that mutually recursive functions might create some very large SCC's in the inter-procedural analysis. We cannot improve our results in this example using context sensitiveness either. The mutually recursivefunctions cannot be completely inlined, so, in the end, we must still match formal and actual parameters to at least one function call |
| [![](http://homepages.dcc.ufmg.br/~fernando/images/c.jpg)](http://code.google.com/p/range-analysis/source/browse/trunk/doc/gallery/srcs/t10.c) | [![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cfgs/t10.main.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cfgs/t10.essa.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/cg.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cgs/t10.inter.pdf) | [![](http://homepages.dcc.ufmg.br/~fernando/images/cg.jpg)](http://homepages.dcc.ufmg.br/~fernando/projects/Range/gallery/pdfs/cgs/t10.inline.pdf) | **t10.c**: this program illustrates a situation in which an one-iteration widening is imprecise. The benchmark has a SCC with two entry-points that are phis, and single iteration followed by widening leads to very conservative bounds. Furthermore, this example shows that, dependenting on the topological ordering we might get different results (but still correct results anyway). If we start propagating intervals through one of the phi's, then we find that the variables are [-inf, 1]. If we use the other, then we get [0, +inf]. If we do one iteration before widening, then we get the least-fixed point [0, 1]. |